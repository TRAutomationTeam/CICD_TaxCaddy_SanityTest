name: Development workflow

on:
  push:
    branches:
      - main
    paths:
      - 'Configue-CICD.txt'

# Here the environment variable is declared in workflow levels 
env: 
  # Replace with your Orchestrator Values 
  PROJECT_FOLDER: ${{ github.action_path }}
  ORCH_URL: ${{ secrets.UIPATH_ORCH_URL }}
  ORCH_TENANT: ${{ secrets.UIPATH_TENANT_ID }}
  ORCH_CLIENT_ID: ${{ secrets.UIPATH_CLIENT_ID }}
  
  # External Application authentication (RECOMMENDED)
  ORCH_APP_ID: ${{ secrets.UIPATH_APP_ID }}
  ORCH_APP_SECRET: ${{ secrets.UIPATH_APP_SECRET }}
  ORCH_APP_SCOPE: ${{ secrets.UIPATH_APP_SCOPE }}
  ORCH_ACC_NAME: ${{ secrets.UIPATH_ACCOUNT_NAME }}
  
  # Remove PAT authentication variables (DEPRECATED)
  # ORCH_USER_KEY: ${{ secrets.UIPATH_USER_KEY }}

jobs:
  print-details:
    runs-on: self-hosted
    steps:
      - name: echo-default-env-variables
        run: |
          Write-Host "Home: $env:HOME"
          Write-Host "GITHUB_WORKFLOW: $env:GITHUB_WORKFLOW"
          Write-Host "GITHUB_ACTIONS: $env:GITHUB_ACTIONS"
          Write-Host "GITHUB_ACTOR: $env:GITHUB_ACTOR"
          Write-Host "GITHUB_REPOSITORY: $env:GITHUB_REPOSITORY"
          Write-Host "GITHUB_EVENT_NAME: $env:GITHUB_EVENT_NAME"
          Write-Host "GITHUB_WORKSPACE: $env:GITHUB_WORKSPACE"
          Write-Host "GITHUB_SHA: $env:GITHUB_SHA"
          Write-Host "GITHUB_REF: $env:GITHUB_REF"

  # CLEANER JOB - Runs first to clean up workspace
  cleaner:
    runs-on: self-hosted
    needs: [print-details]
    steps:
      - name: Enhanced workspace cleanup for self-hosted runner
        shell: pwsh
        run: |
          Write-Host "Enhanced workspace cleanup for self-hosted runner"
          $workspacePath = "${{ github.workspace }}"
          Write-Host "Workspace path: $workspacePath"
          
          # Function to attempt cleanup with multiple methods
          function Invoke-WorkspaceCleanup {
            param([string]$Path)
            
            $cleanupSuccess = $false
            
            if (Test-Path $Path) {
              # Method 1: Try PowerShell Remove-Item
              try {
                Write-Host "Attempting PowerShell cleanup..."
                Get-ChildItem -Path $Path -Recurse -Force | Remove-Item -Force -Recurse -ErrorAction Stop
                Remove-Item -Path $Path -Force -Recurse -ErrorAction Stop
                $cleanupSuccess = $true
                Write-Host "✓ PowerShell cleanup successful"
              }
              catch {
                Write-Host "PowerShell cleanup failed: $($_.Exception.Message)"
              }
              
              # Method 2: Try cmd rmdir if PowerShell failed
              if (-not $cleanupSuccess -and (Test-Path $Path)) {
                try {
                  Write-Host "Attempting cmd rmdir cleanup..."
                  $result = cmd /c "rmdir /s /q `"$Path`" 2>&1"
                  if ($LASTEXITCODE -eq 0) {
                    $cleanupSuccess = $true
                    Write-Host "✓ cmd rmdir cleanup successful"
                  } else {
                    Write-Host "cmd rmdir failed with exit code: $LASTEXITCODE"
                    Write-Host "Output: $result"
                  }
                }
                catch {
                  Write-Host "cmd rmdir cleanup failed: $($_.Exception.Message)"
                }
              }
              
              # Method 3: Try robocopy method for stubborn files
              if (-not $cleanupSuccess -and (Test-Path $Path)) {
                try {
                  Write-Host "Attempting robocopy cleanup method..."
                  $emptyDir = "$env:TEMP\empty_$(Get-Random)"
                  New-Item -ItemType Directory -Path $emptyDir -Force | Out-Null
                  $result = robocopy $emptyDir $Path /MIR /R:0 /W:0 2>&1
                  Remove-Item -Path $emptyDir -Force -ErrorAction SilentlyContinue
                  Remove-Item -Path $Path -Force -ErrorAction SilentlyContinue
                  if (-not (Test-Path $Path)) {
                    $cleanupSuccess = $true
                    Write-Host "✓ robocopy cleanup successful"
                  }
                }
                catch {
                  Write-Host "robocopy cleanup failed: $($_.Exception.Message)"
                }
              }
            } else {
              Write-Host "✓ Workspace directory doesn't exist - nothing to clean"
              $cleanupSuccess = $true
            }
            
            return $cleanupSuccess
          }
          
          # Attempt cleanup
          $success = Invoke-WorkspaceCleanup -Path $workspacePath
          
          # Ensure directory exists for checkout
          if (-not (Test-Path $workspacePath)) {
            New-Item -Path $workspacePath -ItemType Directory -Force | Out-Null
            Write-Host "✓ Created fresh workspace directory"
          }
          
          # Report final status but don't fail the job
          if ($success) {
            Write-Host "✅ Workspace cleanup completed successfully"
          } else {
            Write-Host "⚠️ Workspace cleanup had issues, but continuing with workflow"
            Write-Host "Some files may remain from previous runs"
          }
          
          # Always exit with success to not fail the workflow
          exit 0

  # CONFIG JOB - Runs after cleaner to set up configuration
  config:
    runs-on: self-hosted
    needs: [cleaner]
    outputs:
      build: ${{ steps.get_build.outputs.build }}
      run: ${{ steps.get_run.outputs.run }}
      deploy: ${{ steps.get_deploy.outputs.deploy }}
    steps:
      - name: Check out repository code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          clean: true
          force: true
          set-safe-directory: true
          lfs: false
      
      - name: Post-checkout verification
        shell: pwsh
        run: |
          Write-Host "Post-checkout verification"
          Write-Host "Current working directory: $(Get-Location)"
          Write-Host "Workspace path: ${{ github.workspace }}"
          
          Write-Host "`nWorkspace contents after checkout:"
          Get-ChildItem -Path "${{ github.workspace }}" -Force | ForEach-Object { 
            Write-Host "  - $($_.Name) ($($_.GetType().Name))"
            if ($_.PSIsContainer) {
              Get-ChildItem -Path $_.FullName -Force -ErrorAction SilentlyContinue | Select-Object -First 5 | ForEach-Object {
                Write-Host "    - $($_.Name)"
              }
            }
          }
          
          Write-Host "`nChecking for required files:"
          # Check for config file
          $configFile = "${{ github.workspace }}/Configue-CICD.txt"
          if (Test-Path $configFile) {
            Write-Host "✓ Configue-CICD.txt found"
            Write-Host "Config file contents:"
            Get-Content $configFile | ForEach-Object { Write-Host "  $_" }
          } else {
            Write-Host "✗ Configue-CICD.txt NOT found at: $configFile"
            Write-Host "Available files in workspace:"
            Get-ChildItem -Path "${{ github.workspace }}" -Recurse -File | Select-Object FullName | ForEach-Object { Write-Host "  $($_.FullName)" }
            exit 1
          }
          
          # Check for scripts directory
          $scriptsDir = "${{ github.workspace }}/scripts"
          if (Test-Path $scriptsDir) {
            Write-Host "✓ Scripts directory found"
            Get-ChildItem $scriptsDir | ForEach-Object { Write-Host "  - $($_.Name)" }
          } else {
            Write-Host "⚠️ Scripts directory not found at: $scriptsDir"
          }
      
      - name: Get BUILD value from Configure-CICD.txt
        id: get_build
        shell: pwsh
        run: |
          $configFile = "${{ github.workspace }}/Configue-CICD.txt"
          if (-not (Test-Path $configFile)) {
            Write-Host "Config file not found at: $configFile"
            exit 1
          }
          $build = (Get-Content $configFile | Where-Object { $_ -match '^BUILD[ ]*-[ ]*(.+)$' }) -replace '^BUILD[ ]*-[ ]*',''
          Write-Host "BUILD value: '$build'"
          echo "build=$build" >> $env:GITHUB_OUTPUT
      
      - name: Get RUN value from Configure-CICD.txt
        id: get_run
        shell: pwsh
        run: |
          $configFile = "${{ github.workspace }}/Configue-CICD.txt"
          $run = (Get-Content $configFile | Where-Object { $_ -match '^RUN[ ]*-[ ]*(.+)$' }) -replace '^RUN[ ]*-[ ]*',''
          Write-Host "RUN value: '$run'"
          echo "run=$run" >> $env:GITHUB_OUTPUT
      
      - name: Get DEPLOY value from Configure-CICD.txt
        id: get_deploy
        shell: pwsh
        run: |
          $configFile = "${{ github.workspace }}/Configue-CICD.txt"
          $deploy = (Get-Content $configFile | Where-Object { $_ -match '^DEPLOY[ ]*-[ ]*(.+)$' }) -replace '^DEPLOY[ ]*-[ ]*',''
          Write-Host "DEPLOY value: '$deploy'"
          echo "deploy=$deploy" >> $env:GITHUB_OUTPUT
      
      - name: Write ENVIRONMENT value to file
        shell: pwsh
        run: |
          $configFile = "${{ github.workspace }}/Configue-CICD.txt"
          $envValue = (Get-Content $configFile | Where-Object { $_ -match '^[ ]*ENVIRONMENT[ ]*-[ ]*(.+)$' }) -replace '^[ ]*ENVIRONMENT[ ]*-[ ]*',''
          Write-Host "ENVIRONMENT value: '$envValue'"
          $outputPath = 'C:\Automation Team\CICD'
          if (!(Test-Path $outputPath)) { New-Item -Path $outputPath -ItemType Directory -Force }
          $envFile = Join-Path $outputPath 'environment.txt'
          Remove-Item -Path $envFile -Force -ErrorAction SilentlyContinue
          Set-Content -Path $envFile -Value $envValue

  # RUN JOB - Only runs if RUN=Yes in config and after cleaner and config are complete
  run-uipath-nuget-package:
      needs: [cleaner, config]
      if: needs.config.outputs.run == 'Yes'
      runs-on: self-hosted
      steps:
        - name: Check out repository code
          uses: actions/checkout@v4
          with:
            fetch-depth: 0
            clean: true
            force: true
            set-safe-directory: true
            lfs: false
        
        - name: Verify repository structure for run job
          shell: pwsh
          run: |
            Write-Host "Verifying repository structure for run job"
            Write-Host "Workspace: ${{ github.workspace }}"
            
            # Check for required files
            $requiredItems = @(
              @{Path="Configue-CICD.txt"; Type="File"},
              @{Path="scripts"; Type="Directory"},
              @{Path="scripts/UiPathJobRun.ps1"; Type="File"}
            )
            
            foreach ($item in $requiredItems) {
              $fullPath = Join-Path "${{ github.workspace }}" $item.Path
              if (Test-Path $fullPath) {
                Write-Host "✓ $($item.Path) ($($item.Type)) found"
              } else {
                Write-Host "✗ $($item.Path) ($($item.Type)) NOT found at: $fullPath"
                Write-Host "This is required for the run process"
                exit 1
              }
            }
        
        - name: Load config values from Configue-CICD.txt
          id: load_config
          shell: pwsh
          run: |
            $configFile = "${{ github.workspace }}\Configue-CICD.txt"
            if (-not (Test-Path $configFile)) {
              Write-Host "Config file not found at: $configFile"
              exit 1
            }
            $config = Get-Content $configFile
            Write-Host "Processing config file with $($config.Count) lines"
            foreach ($line in $config) {
              if ($line -match '^[ ]*PROJECT_NAME[ ]*-[ ]*(.+)$') { 
                $value = $Matches[1].Trim()
                Write-Host "Found PROJECT_NAME: '$value'"
                echo "PROJECT_NAME=$value" >> $env:GITHUB_ENV 
              }
              if ($line -match '^[ ]*BRANCH[ ]*-[ ]*(.+)$') { 
                $value = $Matches[1].Trim()
                Write-Host "Found BRANCH: '$value'"
                echo "BRANCH=$value" >> $env:GITHUB_ENV 
              }
              if ($line -match '^[ ]*UIPATH_CLI_PATH[ ]*-[ ]*(.+)$') { 
                $value = $Matches[1].Trim()
                Write-Host "Found UIPATH_CLI_PATH: '$value'"
                echo "UIPATH_CLI_PATH=$value" >> $env:GITHUB_ENV 
              }
              if ($line -match '^[ ]*FOLDER_ORGANIZATION_UNIT[ ]*-[ ]*(.+)$') { 
                $value = $Matches[1].Trim()
                Write-Host "Found FOLDER_ORGANIZATION_UNIT: '$value'"
                echo "FOLDER_ORG_UNIT=$value" >> $env:GITHUB_ENV 
              }
              if ($line -match '^[ ]*FOLDER_DEPLOY_UNIT[ ]*-[ ]*(.+)$') { 
                $value = $Matches[1].Trim()
                Write-Host "Found FOLDER_DEPLOY_UNIT: '$value'"
                echo "FOLDER_DEPLOY_UNIT=$value" >> $env:GITHUB_ENV 
              }
              if ($line -match '^[ ]*MACHINE[ ]*-[ ]*(.+)$') { 
                $value = $Matches[1].Trim()
                Write-Host "Found MACHINE: '$value'"
                echo "MACHINE=$value" >> $env:GITHUB_ENV 
              }
              if ($line -match '^[ ]*ROBOT[ ]*-[ ]*(.+)$') { 
                $value = $Matches[1].Trim()
                Write-Host "Found ROBOT: '$value'"
                echo "ROBOT=$value" >> $env:GITHUB_ENV 
              }
              if ($line -match '^[ ]*TIMEOUT_SEC[ ]*-[ ]*(.+)$') { 
                $value = $Matches[1].Trim()
                Write-Host "Found TIMEOUT_SEC: '$value'"
                echo "TIMEOUT_SEC=$value" >> $env:GITHUB_ENV 
              }
            }
        
        - name: Print loaded config values
          shell: pwsh
          run: |
            Write-Host "Loaded configuration values:"
            Get-ChildItem Env: | Where-Object { $_.Name -in @('PROJECT_NAME','BRANCH','UIPATH_CLI_PATH','FOLDER_ORG_UNIT','FOLDER_DEPLOY_UNIT','MACHINE','ROBOT','TIMEOUT_SEC') } | ForEach-Object { Write-Host "  $($_.Name)=$($_.Value)" }
        
        - name: run Package
          shell: powershell
          env:
            UIPATH_APP_ID: ${{ secrets.UIPATH_APP_ID }}
            UIPATH_APP_SECRET: ${{ secrets.UIPATH_APP_SECRET }}
            UIPATH_APP_SCOPE: ${{ secrets.UIPATH_APP_SCOPE }}
          run: |
            Write-Host "Starting UiPath job run with External Application authentication"
            Write-Host "PROJECT_NAME from config: ${{ env.PROJECT_NAME }}"
            
            # DEBUG: Print all authentication values (masking sensitive ones)
            Write-Host "=== DEBUG: External Application Authentication Values ==="
            Write-Host "ORCH_URL: ${{ env.ORCH_URL }}"
            Write-Host "ORCH_TENANT: ${{ env.ORCH_TENANT }}"
            Write-Host "ORCH_ACC_NAME: ${{ env.ORCH_ACC_NAME }}"
            Write-Host "ORCH_APP_ID: $(if($env:UIPATH_APP_ID) { $env:UIPATH_APP_ID.Substring(0, [Math]::Min(8, $env:UIPATH_APP_ID.Length)) + '***' } else { 'NOT SET' })"
            Write-Host "ORCH_APP_SECRET: $(if($env:UIPATH_APP_SECRET) { 'SET (length: ' + $env:UIPATH_APP_SECRET.Length + ' characters)' } else { 'NOT SET' })"
            Write-Host "ORCH_APP_SCOPE: ${{ env.ORCH_APP_SCOPE }}"
            Write-Host "================================================"
            
            $jobRunScript = "${{ github.workspace }}\scripts\UiPathJobRun.ps1"
            if (-not (Test-Path $jobRunScript)) {
              Write-Host "UiPathJobRun.ps1 not found at: $jobRunScript"
              exit 1
            }
            
            Write-Host "Job run parameters:"
            Write-Host "  Process Name: ${{ env.PROJECT_NAME }}"
            Write-Host "  Orchestrator URL: ${{ env.ORCH_URL }}"
            Write-Host "  Tenant: ${{ env.ORCH_TENANT }}"
            Write-Host "  Account Name: ${{ env.ORCH_ACC_NAME }}"
            Write-Host "  Folder: ${{ env.FOLDER_ORG_UNIT }}"
            Write-Host "  Machine: ${{ env.MACHINE }}"
            Write-Host "  Robot: ${{ env.ROBOT }}"
            Write-Host "  CLI Path: ${{ env.UIPATH_CLI_PATH }}"
            Write-Host "  Timeout: ${{ env.TIMEOUT_SEC }}"
            
            # DEBUG: Print the exact parameters that will be passed to the script
            Write-Host "=== DEBUG: Script Parameters (External App) ==="
            Write-Host "processName: '${{ env.PROJECT_NAME }}'"
            Write-Host "uriOrch: '${{ env.ORCH_URL }}'"
            Write-Host "tenantlName: '${{ env.ORCH_TENANT }}'"
            Write-Host "accountForApp: '${{ env.ORCH_ACC_NAME }}'"
            Write-Host "applicationId: $(if($env:UIPATH_APP_ID) { 'SET (first 8 chars: ' + $env:UIPATH_APP_ID.Substring(0, [Math]::Min(8, $env:UIPATH_APP_ID.Length)) + ')' } else { 'NOT SET' })"
            Write-Host "applicationSecret: $(if($env:UIPATH_APP_SECRET) { 'SET (length: ' + $env:UIPATH_APP_SECRET.Length + ')' } else { 'NOT SET' })"
            Write-Host "applicationScope: '${{ env.ORCH_APP_SCOPE }}'"
            Write-Host "folder_organization_unit: '${{ env.FOLDER_ORG_UNIT }}'"
            Write-Host "machine: '${{ env.MACHINE }}'"
            Write-Host "robots: '${{ env.ROBOT }}'"
            Write-Host "uipathCliFilePath: '${{ env.UIPATH_CLI_PATH }}'"
            Write-Host "timeout: '${{ env.TIMEOUT_SEC }}'"
            Write-Host "======================================"
            
            # Call the script with External Application authentication parameters
            & $jobRunScript `
              -processName "${{ env.PROJECT_NAME }}" `
              -uriOrch "${{ env.ORCH_URL }}" `
              -tenantlName "${{ env.ORCH_TENANT }}" `
              -accountForApp "${{ env.ORCH_ACC_NAME }}" `
              -applicationId $env:UIPATH_APP_ID `
              -applicationSecret $env:UIPATH_APP_SECRET `
              -applicationScope "${{ env.ORCH_APP_SCOPE }}" `
              -folder_organization_unit "${{ env.FOLDER_ORG_UNIT }}" `
              -machine "${{ env.MACHINE }}" `
              -robots "${{ env.ROBOT }}" `
              -uipathCliFilePath "${{ env.UIPATH_CLI_PATH }}" `
              -timeout "${{ env.TIMEOUT_SEC }}"
