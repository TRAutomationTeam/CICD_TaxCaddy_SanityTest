name: Development workflow

on:
  push:
    branches:
      - main
    paths:
      - 'Configue-CICD.txt'

# Here the environment variable is declared in workflow levels 
env: 
  # Replace with your Orchestrator Values 
  PROJECT_FOLDER: ${{ github.action_path }}
  ORCH_URL: ${{ secrets.UIPATH_ORCH_URL }}
  ORCH_TENANT: ${{ secrets.UIPATH_TENANT_ID }}
  ORCH_CLIENT_ID: ${{ secrets.UIPATH_CLIENT_ID }}
  
  # External Application authentication (RECOMMENDED)
  ORCH_APP_ID: ${{ secrets.UIPATH_APP_ID }}
  ORCH_APP_SECRET: ${{ secrets.UIPATH_APP_SECRET }}
  ORCH_APP_SCOPE: ${{ secrets.UIPATH_APP_SCOPE }}
  ORCH_ACC_NAME: ${{ secrets.UIPATH_ACCOUNT_NAME }}

jobs:
  print-details:
    runs-on: self-hosted
    steps:
      - name: echo-default-env-variables
        run: |
          Write-Host "Home: $env:HOME"
          Write-Host "GITHUB_WORKFLOW: $env:GITHUB_WORKFLOW"
          Write-Host "GITHUB_ACTIONS: $env:GITHUB_ACTIONS"
          Write-Host "GITHUB_ACTOR: $env:GITHUB_ACTOR"
          Write-Host "GITHUB_REPOSITORY: $env:GITHUB_REPOSITORY"
          Write-Host "GITHUB_EVENT_NAME: $env:GITHUB_EVENT_NAME"
          Write-Host "GITHUB_WORKSPACE: $env:GITHUB_WORKSPACE"
          Write-Host "GITHUB_SHA: $env:GITHUB_SHA"
          Write-Host "GITHUB_REF: $env:GITHUB_REF"

  # CLEANER JOB - Runs first to clean up workspace
  cleaner:
    runs-on: self-hosted
    needs: [print-details]
    steps:
      - name: Enhanced workspace cleanup for self-hosted runner
        shell: pwsh
        run: |
          Write-Host "Enhanced workspace cleanup for self-hosted runner"
          $workspacePath = "${{ github.workspace }}"
          Write-Host "Workspace path: $workspacePath"
          
          # Function to attempt cleanup with multiple methods
          function Invoke-WorkspaceCleanup {
            param([string]$Path)
            
            $cleanupSuccess = $false
            
            if (Test-Path $Path) {
              # Method 1: Try PowerShell Remove-Item
              try {
                Write-Host "Attempting PowerShell cleanup..."
                Get-ChildItem -Path $Path -Recurse -Force | Remove-Item -Force -Recurse -ErrorAction Stop
                Remove-Item -Path $Path -Force -Recurse -ErrorAction Stop
                $cleanupSuccess = $true
                Write-Host "✓ PowerShell cleanup successful"
              }
              catch {
                Write-Host "PowerShell cleanup failed: $($_.Exception.Message)"
              }
              
              # Method 2: Try cmd rmdir if PowerShell failed
              if (-not $cleanupSuccess -and (Test-Path $Path)) {
                try {
                  Write-Host "Attempting cmd rmdir cleanup..."
                  $result = cmd /c "rmdir /s /q `"$Path`" 2>&1"
                  if ($LASTEXITCODE -eq 0) {
                    $cleanupSuccess = $true
                    Write-Host "✓ cmd rmdir cleanup successful"
                  } else {
                    Write-Host "cmd rmdir failed with exit code: $LASTEXITCODE"
                    Write-Host "Output: $result"
                  }
                }
                catch {
                  Write-Host "cmd rmdir cleanup failed: $($_.Exception.Message)"
                }
              }
              
              # Method 3: Try robocopy method for stubborn files
              if (-not $cleanupSuccess -and (Test-Path $Path)) {
                try {
                  Write-Host "Attempting robocopy cleanup method..."
                  $emptyDir = "$env:TEMP\empty_$(Get-Random)"
                  New-Item -ItemType Directory -Path $emptyDir -Force | Out-Null
                  $result = robocopy $emptyDir $Path /MIR /R:0 /W:0 2>&1
                  Remove-Item -Path $emptyDir -Force -ErrorAction SilentlyContinue
                  Remove-Item -Path $Path -Force -ErrorAction SilentlyContinue
                  if (-not (Test-Path $Path)) {
                    $cleanupSuccess = $true
                    Write-Host "✓ robocopy cleanup successful"
                  }
                }
                catch {
                  Write-Host "robocopy cleanup failed: $($_.Exception.Message)"
                }
              }
            } else {
              Write-Host "✓ Workspace directory doesn't exist - nothing to clean"
              $cleanupSuccess = $true
            }
            
            return $cleanupSuccess
          }
          
          # Attempt cleanup
          $success = Invoke-WorkspaceCleanup -Path $workspacePath
          
          # Ensure directory exists for checkout
          if (-not (Test-Path $workspacePath)) {
            New-Item -Path $workspacePath -ItemType Directory -Force | Out-Null
            Write-Host "✓ Created fresh workspace directory"
          }
          
          # Report final status but don't fail the job
          if ($success) {
            Write-Host "✅ Workspace cleanup completed successfully"
          } else {
            Write-Host "⚠️ Workspace cleanup had issues, but continuing with workflow"
            Write-Host "Some files may remain from previous runs"
          }
          
          # Always exit with success to not fail the workflow
          exit 0

  # CONFIG JOB - Runs after cleaner to set up configuration
  config:
    runs-on: self-hosted
    needs: [cleaner]
    outputs:
      build: ${{ steps.get_build.outputs.build }}
      run: ${{ steps.get_run.outputs.run }}
      environment: ${{ steps.get_environment.outputs.environment }}
      project_name: ${{ steps.get_project_name.outputs.project_name }}
    steps:
      - name: Check out repository code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          clean: true
          force: true
          set-safe-directory: true
          lfs: false
      
      - name: Post-checkout verification
        shell: pwsh
        run: |
          Write-Host "Post-checkout verification"
          Write-Host "Current working directory: $(Get-Location)"
          Write-Host "Workspace path: ${{ github.workspace }}"
          
          Write-Host "`nWorkspace contents after checkout:"
          Get-ChildItem -Path "${{ github.workspace }}" -Force | ForEach-Object { 
            Write-Host "  - $($_.Name) ($($_.GetType().Name))"
            if ($_.PSIsContainer) {
              Get-ChildItem -Path $_.FullName -Force -ErrorAction SilentlyContinue | Select-Object -First 5 | ForEach-Object {
                Write-Host "    - $($_.Name)"
              }
            }
          }
          
          Write-Host "`nChecking for required files:"
          # Check for config file
          $configFile = "${{ github.workspace }}/Configue-CICD.txt"
          if (Test-Path $configFile) {
            Write-Host "✓ Configue-CICD.txt found"
            Write-Host "Config file contents:"
            Get-Content $configFile | ForEach-Object { Write-Host "  $_" }
          } else {
            Write-Host "✗ Configue-CICD.txt NOT found at: $configFile"
            Write-Host "Available files in workspace:"
            Get-ChildItem -Path "${{ github.workspace }}" -Recurse -File | Select-Object FullName | ForEach-Object { Write-Host "  $($_.FullName)" }
            exit 1
          }
          
          # Check for scripts directory
          $scriptsDir = "${{ github.workspace }}/scripts"
          if (Test-Path $scriptsDir) {
            Write-Host "✓ Scripts directory found"
            Get-ChildItem $scriptsDir | ForEach-Object { Write-Host "  - $($_.Name)" }
          } else {
            Write-Host "⚠️ Scripts directory not found at: $scriptsDir"
          }
      
      - name: Get BUILD value from Configure-CICD.txt
        id: get_build
        shell: pwsh
        run: |
          $configFile = "${{ github.workspace }}/Configue-CICD.txt"
          if (-not (Test-Path $configFile)) {
            Write-Host "Config file not found at: $configFile"
            exit 1
          }
          $build = (Get-Content $configFile | Where-Object { $_ -match '^BUILD[ ]*-[ ]*(.+)$' }) -replace '^BUILD[ ]*-[ ]*',''
          Write-Host "BUILD value: '$build'"
          echo "build=$build" >> $env:GITHUB_OUTPUT
      
      - name: Get RUN value from Configure-CICD.txt
        id: get_run
        shell: pwsh
        run: |
          $configFile = "${{ github.workspace }}/Configue-CICD.txt"
          $run = (Get-Content $configFile | Where-Object { $_ -match '^RUN[ ]*-[ ]*(.+)$' }) -replace '^RUN[ ]*-[ ]*',''
          Write-Host "RUN value: '$run'"
          echo "run=$run" >> $env:GITHUB_OUTPUT
      
      - name: Get ENVIRONMENT value from Configure-CICD.txt
        id: get_environment
        shell: pwsh
        run: |
          $configFile = "${{ github.workspace }}/Configue-CICD.txt"
          $envValue = (Get-Content $configFile | Where-Object { $_ -match '^[ ]*ENVIRONMENT[ ]*-[ ]*(.+)$' }) -replace '^[ ]*ENVIRONMENT[ ]*-[ ]*',''
          Write-Host "ENVIRONMENT value: '$envValue'"
          echo "environment=$envValue" >> $env:GITHUB_OUTPUT
      
      - name: Get PROJECT_NAME value from Configure-CICD.txt
        id: get_project_name
        shell: pwsh
        run: |
          $configFile = "${{ github.workspace }}/Configue-CICD.txt"
          $projectName = (Get-Content $configFile | Where-Object { $_ -match '^[ ]*PROJECT_NAME[ ]*-[ ]*(.+)$' }) -replace '^[ ]*PROJECT_NAME[ ]*-[ ]*',''
          Write-Host "PROJECT_NAME value: '$projectName'"
          echo "project_name=$projectName" >> $env:GITHUB_OUTPUT

  # BUILD JOB - Conditional build job (DISABLED - will always be skipped)
  build:
    runs-on: self-hosted
    needs: [config]
    # FORCE SKIP BUILD - Change this condition to false to always skip build
    if: false  # This will always skip the build job
    steps:
      - name: Check out repository code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          clean: true
          force: true
          set-safe-directory: true
          lfs: false
      
      - name: Build UiPath Project
        shell: pwsh
        run: |
          Write-Host "🔨 Starting UiPath project build process..."
          Write-Host "Environment: ${{ needs.config.outputs.environment }}"
          Write-Host "Project Name: ${{ needs.config.outputs.project_name }}"
          
          # Add your build logic here
          # For example, using UiPath CLI to build the project
          Write-Host "✅ Build process completed successfully"

  # RUN JOB - Executes UiPath workflows (MODIFIED to run regardless of build)
  run:
    runs-on: self-hosted
    needs: [config, build]
    # UPDATED CONDITION: Run if config succeeded and run=true, regardless of build status
    if: always() && needs.config.result == 'success' && needs.config.outputs.run == 'true' && (needs.build.result == 'success' || needs.build.result == 'skipped')
    steps:
      - name: Check out repository code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          clean: true
          force: true
          set-safe-directory: true
          lfs: false
      
      - name: Debug External Application Authentication Values
        shell: pwsh
        run: |
          Write-Host "Starting UiPath job run with External Application authentication"
          Write-Host "PROJECT_NAME from config: ${{ needs.config.outputs.project_name }}"
          Write-Host "=== DEBUG: External Application Authentication Values ==="
          Write-Host "ORCH_URL: $env:ORCH_URL"
          Write-Host "ORCH_TENANT: $env:ORCH_TENANT"
          Write-Host "ORCH_ACC_NAME: $env:ORCH_ACC_NAME"
          Write-Host "ORCH_APP_ID: $($env:ORCH_APP_ID.Substring(0,8))***"
          Write-Host "ORCH_APP_SECRET: SET (length: $($env:ORCH_APP_SECRET.Length) characters)"
          Write-Host "ORCH_APP_SCOPE: $env:ORCH_APP_SCOPE"
          Write-Host "================================================"
      
      - name: Run UiPath Job via API
        shell: pwsh
        run: |
          Write-Host "Job run parameters:"
          Write-Host "  Process Name: ${{ needs.config.outputs.project_name }}"
          Write-Host "  Orchestrator URL: $env:ORCH_URL"
          Write-Host "  Tenant: $env:ORCH_TENANT"
          Write-Host "  Account Name: $env:ORCH_ACC_NAME"
          Write-Host "  Folder: Automation"
          Write-Host "  Machine: e2-dev-upth01"
          Write-Host "  Robot: minal-unattended"
          Write-Host "  Timeout: 15000"
          
          Write-Host "=== DEBUG: Script Parameters (External App) ==="
          Write-Host "processName: '${{ needs.config.outputs.project_name }}'"
          Write-Host "uriOrch: '$env:ORCH_URL'"
          Write-Host "tenantlName: '$env:ORCH_TENANT'"
          Write-Host "accountForApp: '$env:ORCH_ACC_NAME'"
          Write-Host "applicationId: SET (first 8 chars: $($env:ORCH_APP_ID.Substring(0,8)))"
          Write-Host "applicationSecret: SET (length: $($env:ORCH_APP_SECRET.Length))"
          Write-Host "applicationScope: '$env:ORCH_APP_SCOPE'"
          Write-Host "folder_organization_unit: 'Automation'"
          Write-Host "machine: 'e2-dev-upth01'"
          Write-Host "robots: 'minal-unattended'"
          Write-Host "timeout: '15000'"
          Write-Host "======================================"
          
          # Execute the updated PowerShell script
          $scriptPath = "${{ github.workspace }}\scripts\UiPathJobRun.ps1"
          
          if (-not (Test-Path $scriptPath)) {
            Write-Host "❌ UiPathJobRun.ps1 script not found at: $scriptPath" -ForegroundColor Red
            Write-Host "Available files in scripts directory:"
            Get-ChildItem "${{ github.workspace }}\scripts" -ErrorAction SilentlyContinue | ForEach-Object { 
              Write-Host "  - $($_.Name)"
            }
            exit 1
          }
          
          try {
            Write-Host "🚀 Executing UiPath job run script..."
            
            & $scriptPath `
              -processName "${{ needs.config.outputs.project_name }}" `
              -uriOrch "$env:ORCH_URL" `
              -tenantlName "$env:ORCH_TENANT" `
              -accountForApp "$env:ORCH_ACC_NAME" `
              -applicationId "$env:ORCH_APP_ID" `
              -applicationSecret "$env:ORCH_APP_SECRET" `
              -applicationScope "$env:ORCH_APP_SCOPE" `
              -folder_organization_unit "Automation" `
              -robots "minal-unattended" `
              -machine "e2-dev-upth01" `
              -timeout "15000" `
              -wait "true" `
              -fail_when_job_fails "true"
            
            if ($LASTEXITCODE -eq 0) {
              Write-Host "✅ UiPath job completed successfully!" -ForegroundColor Green
            } else {
              Write-Host "❌ UiPath job failed with exit code: $LASTEXITCODE" -ForegroundColor Red
              exit $LASTEXITCODE
            }
          }
          catch {
            Write-Host "❌ Error executing UiPath job: $($_.Exception.Message)" -ForegroundColor Red
            Write-Host "Full error details: $($_.Exception | Out-String)" -ForegroundColor Red
            exit 1
          }

  # SUMMARY JOB - Always runs to provide workflow summary
  summary:
    runs-on: self-hosted
    needs: [config, build, run]
    if: always()
    steps:
      - name: Workflow Summary
        shell: pwsh
        run: |
          Write-Host "📊 WORKFLOW EXECUTION SUMMARY"
          Write-Host "================================"
          Write-Host "Configuration:"
          Write-Host "  - Build: ${{ needs.config.outputs.build }} (FORCED TO SKIP)"
          Write-Host "  - Run: ${{ needs.config.outputs.run }}"
          Write-Host "  - Environment: ${{ needs.config.outputs.environment }}"
          Write-Host "  - Project Name: ${{ needs.config.outputs.project_name }}"
          Write-Host ""
          Write-Host "Job Results:"
          Write-Host "  - Config: ${{ needs.config.result }}"
          Write-Host "  - Build: ${{ needs.build.result }} (INTENTIONALLY SKIPPED)"
          Write-Host "  - Run: ${{ needs.run.result }}"
          Write-Host ""
          
          $overallSuccess = $true
          if ("${{ needs.config.result }}" -eq "failure") { $overallSuccess = $false }
          # Don't check build result since we're intentionally skipping it
          if ("${{ needs.config.outputs.run }}" -eq "true" -and "${{ needs.run.result }}" -eq "failure") { $overallSuccess = $false }
          
          if ($overallSuccess) {
            Write-Host "🎉 WORKFLOW COMPLETED SUCCESSFULLY!" -ForegroundColor Green
            Write-Host "Note: Build job was intentionally skipped" -ForegroundColor Yellow
          } else {
            Write-Host "❌ WORKFLOW COMPLETED WITH ERRORS!" -ForegroundColor Red
            exit 1
          }
